monetate.c.cr({"data": "(function() {\n  function getCookieDomain() {\n    const host = window.location.hostname;\n    return (\n      host.match(/^[\\d.]+$|/)[0] ||\n    (host.match(/[^.]+\\.(\\w{2,3}\\.\\w{2}|\\w{2,})$/) || [ host ])[0]\n    );\n  }\n\n  function getCookie(cookieName) {\n    let match = document.cookie.match(new RegExp('(^|;|;\\\\s)' + cookieName + '=([^;]+)'));\n    return match ? match[2] : '';\n  }\n\n  function setCookie(name, value, expiresAfterDays, domain) {\n    const DAY = (24 * 1000 * 60 * 60);\n\n    document.cookie = [\n      name + '=' + value.toString(),\n      'domain=' + (domain || getCookieDomain()),\n      'path=/',\n      expiresAfterDays ? 'max-age=' + (DAY * expiresAfterDays) : ''\n    ].join(';');\n  }\n\n  function when(condition, stopAfter = 7000) {\n    return new Promise((resolve, reject) => {\n      let stopByTimeout = false;\n      let value = false;\n\n      window.setTimeout(() => { stopByTimeout = true; }, stopAfter);\n\n      (function _innerWaitFor() {\n        if (stopByTimeout) { reject('when stopped: by timeout'); return; }\n        try { value = condition(); } catch (e) { /* silent */ }\n        value ? resolve(value) : window.setTimeout(_innerWaitFor, 50);\n      })();\n    });\n  }\n\n  function getScope(namespace) {\n    window.lc = window.lc || {};\n    window.lc.scope = window.lc.scope || {};\n    window.lc.scope[namespace] = window.lc.scope[namespace] || {};\n    return window.lc.scope[namespace];\n  }\n\n  function isInIframe(base = window) {\n    try {\n      return base.self !== base.parent;\n    } catch (e) {\n      return true;\n    }\n  }\n\n  function getLogger(namespace, cookieName, cookieValue) {\n    const settings = { namespace, cookieName, cookieValue };\n    const defaultColour = 'blue';\n    const typesMap = {\n      info: 'blue',\n      log: 'blue',\n      ok: 'green',\n      error: 'crimson',\n      warn: '#f9a66d'\n    };\n\n    return Object.keys(typesMap).reduce(function(prev, curr) {\n      prev[curr] = getLoggingMethod(settings, typesMap[curr], false);\n      prev[curr + 'TS'] = getLoggingMethod(settings, typesMap[curr], true);\n      return prev;\n    }, getLoggingMethod(settings, defaultColour, false));\n  }\n\n  function getLoggingMethod(settings, color, timeStampNeeded) {\n    const CONSOLE_METHOD = 'info';\n\n    return function () {\n      if (!isEnabled(settings)) return;\n\n      const timestamp = new Date().toLocaleTimeString('en-GB');\n      const iframeSuffix = isInIframe() ? ' [iframe]' : '';\n      const tsSuffix = timeStampNeeded ? (` [${timestamp}]`) : '';\n      const descriptor = `%c[${settings.namespace}]:${tsSuffix}${iframeSuffix}`;\n\n      if (window.console && typeof window.console[CONSOLE_METHOD] === 'function') {\n        window.console[CONSOLE_METHOD](descriptor, 'color: ' + color, ...arguments);\n      }\n    };\n  }\n\n  function isEnabled({ cookieName, cookieValue = '' }) {\n    const currentCookieValue = getCookie(cookieName);\n\n    if (cookieValue === '') return currentCookieValue;\n    return (currentCookieValue === cookieValue.toString());\n  }\n\n  function getNormalPath(url) {\n    return (\n      (url || window.location.pathname)\n        .replace(window.location.origin, '')\n        .replace(/[\\?#].*$/, '')\n        .replace(/\\/$/, '')\n    );\n  }\n\n  const CENTRAL_STORAGE = 'lc-storage';\n  const SESSION_CONTROL_COOKIE = 'lc-session';\n  const CENTRAL_STORAGE_LIMIT = 300;\n\n  const storage = {\n    getItem: function(itemName) {\n      let storageObj = getStorageData();\n      if (!storageObj[itemName]) return null;\n      return storageObj[itemName].v;\n    },\n    setItem: function(itemName, itemValue, itemExpiresAfterDays) {\n      const day = (24 * 1000 * 60 * 60);\n      let storageObj = getStorageData();\n      let expires = (itemExpiresAfterDays || 0);\n      if (expires < 0) {\n        storageObj[itemName] && delete storageObj[itemName];\n      } else {\n        storageObj[itemName] = storageObj[itemName] || {};\n        storageObj[itemName].v = itemValue;\n        storageObj[itemName].e = itemExpiresAfterDays ? ((new Date()).getTime() + Math.round(itemExpiresAfterDays * day)) : 'session';\n      }\n\n      saveDataToStorage(storageObj);\n    },\n    removeItem: function(itemName) {\n      this.setItem(itemName, '', -1);\n    }\n  };\n\n  function getStorageData() {\n    let storageObj = getParsedDataFromLS();\n    return clearExpiredData(storageObj);\n  }\n\n  function getParsedDataFromLS() {\n    let item = window.localStorage.getItem(CENTRAL_STORAGE) || '{}';\n    let itemParsed = {};\n    try {\n      itemParsed = JSON.parse(item);\n    } catch (e) {\n    // silent\n    }\n\n    return itemParsed;\n  }\n\n  function saveDataToStorage(data) {\n    window.localStorage.setItem(CENTRAL_STORAGE, JSON.stringify(data));\n  }\n\n  function clearExpiredData(storageObj) {\n    const isNewSession = !Boolean(getCookie(SESSION_CONTROL_COOKIE));\n    setCookie(SESSION_CONTROL_COOKIE, 1);\n\n    Object.keys(storageObj).forEach(function(item) {\n      const expirationDate = storageObj[item].e;\n      const expired = (\n        (expirationDate === 'session') ?\n          (isNewSession) :\n          ((new Date()).getTime() > expirationDate)\n      );\n\n      if (expired) {\n        delete storageObj[item];\n      }\n    });\n\n    if (Object.keys(storageObj).length > CENTRAL_STORAGE_LIMIT) ;\n\n    saveDataToStorage(storageObj);\n    return storageObj;\n  }\n\n  function initWatcher(initPeriodicChecks) {\n    const allCheckers = [];\n    initPeriodicChecks((data) => {\n      allCheckers.forEach(updateResults => updateResults(data));\n    });\n\n    return {\n      addChecker: function({ skipImmediateCheck, checkerFn, onIn, onOut, onAllOut, onTrue, onFalse, timeout }) {\n        let currentList = [];\n        let currentBooleanStatus = false;\n\n        skipImmediateCheck ? updateResults({ isExistingCheck: true, skipCallbacks: true}) : updateResults({ isExistingCheck: true });\n        allCheckers.push(\n          typeof timeout === 'undefined' ?\n            updateResults :\n            (data) => setTimeout(() => updateResults(data), timeout)\n        );\n\n        function updateResults(options = {}) {\n          const { isExistingCheck, skipCallbacks } = options;\n          const checksUpdate = getChecksUpdate();\n\n          currentList = checksUpdate.newList;\n          if (typeof checksUpdate.newBooleanStatus !== 'undefined') {\n            currentBooleanStatus = checksUpdate.newBooleanStatus;\n          }\n\n          !skipCallbacks && runCallbacks(checksUpdate, isExistingCheck || false);\n        }\n\n        function getChecksUpdate() {\n          const checkResult = checkerFn();\n\n          if (checkResult instanceof NodeList || Array.isArray(checkResult)) {\n            return { ...getBooleanUpdate(checkResult), ...getListUpdate(checkResult), checkResult };\n          }\n\n          return { ...getBooleanUpdate(checkResult), ...getListUpdate([]), checkResult };\n        }\n\n        function getListUpdate(checkResult) {\n          const newList = Array.from(checkResult);\n          const inList = [];\n          const outList = [];\n\n          newList.forEach(element => (!currentList.includes(element) && inList.push(element)));\n          currentList.forEach(element => (!newList.includes(element) && outList.push(element)));\n\n          return { newList, inList, outList };\n        }\n\n        function getBooleanUpdate(checkResult) {\n          const newBooleanStatus = Boolean(checkResult);\n\n          if (newBooleanStatus !== currentBooleanStatus) {\n            return { newBooleanStatus };\n          }\n\n          return {};\n        }\n\n        function runCallbacks({ inList, outList, newList, newBooleanStatus, checkResult }, isExistingCheck) {\n          if (inList.length) {\n            try { onIn && onIn(inList, isExistingCheck); } catch (e) { /* silent */ }\n          }\n\n          if (outList.length) {\n            try { onOut && onOut(outList); } catch (e) { /* silent */ }\n\n            if (!newList.length) {\n              try { onAllOut && onAllOut(outList); } catch (e) { /* silent */ }\n            }\n          }\n\n          if (newBooleanStatus === true) {\n            try { onTrue && onTrue(checkResult); } catch (e) { /* silent */ }\n          }\n\n          if (newBooleanStatus === false) {\n            try { onFalse && onFalse(); } catch (e) { /* silent */ }\n          }\n        }\n      }\n    };\n  }\n\n  const CAMPAIGN_ID = 'iberia271';\n  const CAMPAIGN_PREFIX = 'lc-iberia271';\n  const CAMPAIGN_FULL_NAME = 'lc-iberia271-checkin-seats-pick';\n  getScope(CAMPAIGN_ID);\n\n  // ////\n  //\n  // JS Action template for MNTTGF 2.0 - 6 febrero 2023\n  // Template de acci\u00f3n javascript para utilizar con las MONETATE GLOBAL FUNCTIONS (MNTTGF) basado en promesas de js\n  //\n  // ////\n\n  function registerAndExecuteVariant({ variantName, campaignName, variantFn }) {\n    try {\n      wait4MNTTGF()\n        .then(processVariant, falloMNTTGFLoad);\n    } catch (err) {\n      log2Con(err.toString(), 'error');\n    }\n\n    function processVariant() {\n      checkPageReady()\n        .then(() => {\n          log2Con('OK - Rendered', 'warning');\n          log2GTM();\n          variantFn();\n          log2Con('Fin de la variante', 'info');\n        })\n        .catch(err => {\n          log2Con('Error!!! ' + err.toString(), 'error');\n        });\n    }\n\n    function wait4MNTTGF() {\n      return new Promise(function(resolve, reject) {\n      // eslint-disable-next-line no-console\n        console.debug(new Date().toLocaleString('es-ES', {timeZoneName: 'short'}) + ' - [' + campaignName + '|' + variantName + '] - waiting 4 MNTTGF to load...');\n\n        // Evaluamos si las MNTTGF se han cargado cada 100 milisegundos y si es as\u00ed resolvemos la promesa\n        setTimeout(() => {\n          let intervalMNTTGF;\n          let timeoutMGTTGF;\n\n          intervalMNTTGF = setInterval(function() {\n            if (window.mnttGF) {\n              log2Con('MNTTGF running!! :)', 'info');\n              clearInterval(intervalMNTTGF);\n              clearTimeout(timeoutMGTTGF);\n              resolve();\n            } else if (window.mnttGF === 'locked') {\n              log2Con('ATTENTION!!!! MNTTGF LOCKED!!!!!!!!!!!!!!!!!!!!!!!!! :(', 'warning');\n              clearInterval(intervalMNTTGF);\n              clearTimeout(timeoutMGTTGF);\n              resolve();\n            } else if (window.mnttGF === 'loading') {\n              log2Con('loading MNTTGF... :|', 'info');\n            }\n          }, 100);\n\n          // Si tras 10 segundos no se han cargado las MNTTGF rechazamos la promesa\n          timeoutMGTTGF = setTimeout(() => {\n            clearInterval(intervalMNTTGF);\n            reject();\n          }, 10000);\n        }, 0);\n      });\n    }\n\n    function falloMNTTGFLoad() {\n      const timestamp = new Date().toLocaleString('es-ES', {timeZoneName: 'short'});\n      const texto = 'MNTTGF TIMEOUT!!!: No se ha cargado la experiencia MONETATE GLOBAL FUNCTIONS :(';\n      const aviso = timestamp + ' [' + campaignName + '|' + variantName + ']:--> ' + texto;\n\n      // eslint-disable-next-line no-console\n      console.error(aviso);\n\n      const avisoHTML = '<div class=\"mnttgf_error\">' + timestamp + ': ' + texto + '</div>';\n\n      if (!document.getElementById('MNTT_LOGS')) {\n        const output = '<div data-nosnippet id=\"MNTT_LOGS\" class=\"mnttgf_logs\" style=\"display: none;\"></div>';\n        document.querySelector('body').insertAdjacentHTML('beforeend', output);\n      }\n\n      const idText = (campaignName + '_' + variantName).trim();\n\n      if (!document.getElementById(idText)) {\n        const output = '<div id=\"' + idText + '\" class=\"mnttgf_logs\" style=\"display: none;\">Monetate log: [' + campaignName + '][' + variantName + '] </div>';\n        document.getElementById('MNTT_LOGS').insertAdjacentHTML('beforeend', output);\n      }\n\n      document.getElementById(idText).insertAdjacentHTML('beforeend', avisoHTML);\n    }\n\n    function checkPageReady(pageCondition = function() { return true; }) {\n      return window.mnttCheckPageReady(campaignName, variantName, pageCondition);\n    }\n\n    // function checkConditions(funcionCondicion, conditionDescription = '') {\n    //   return window.mnttCheckConditions(campaignName, variantName, funcionCondicion, conditionDescription);\n    // }\n\n    // function checkTarget(target, currentValue, targetDescription = '') {\n    //   return window.mnttCheckTarget(campaignName, variantName, target, currentValue, targetDescription);\n    // }\n\n    function log2Con(texto, criticidad = 'info') {\n      window.mnttLog2Con(campaignName, variantName, texto, criticidad);\n    }\n\n    // function obj2Con(objeto) {\n    //   window.mnttObj2Con(campaignName, variantName, objeto);\n    // }\n\n    function log2GTM(test = campaignName, action = variantName) {\n      window.mnttLog2GTM(test, action);\n    }\n\n  // function sendEventQM(eventNum, eventValue = '', eventDesc = '') {\n  //   window.mnttSendEventQM(campaignName, variantName, eventNum, eventValue, eventDesc);\n  // }\n  }\n\n  const SCRIPT_NAME = 'variant-v1';\n  const SCRIPT_PREFIX = `${CAMPAIGN_PREFIX}-${SCRIPT_NAME}`;\n  const logger = getLogger(SCRIPT_PREFIX, 'lc-debug');\n  const debugLogger = getLogger(SCRIPT_PREFIX + ' [debug]', 'lc-debug', CAMPAIGN_ID);\n\n  function registerAndExecute(executeVariant) {\n    registerAndExecuteVariant({\n      variantName: SCRIPT_NAME,\n      campaignName: CAMPAIGN_FULL_NAME,\n      variantFn: () => {\n        executeVariant();\n        logger.ok('variant registered');\n      }\n    });\n  }\n\n  function onNodesAppear({ checkerFn, onIn, onOut, onAllOut, onTrue, onFalse, logger }) {\n    when(getMutationsTarget)\n      .then((mutationsTarget) => {\n        const mutationsWatcher = initGlobalMutationsWatcher(mutationsTarget);\n        mutationsWatcher && mutationsWatcher.addChecker({ checkerFn, onIn, onOut, onAllOut, onTrue, onFalse });\n      })\n      .catch(e => logger && logger.error(e));\n  }\n\n  function initGlobalMutationsWatcher(mutationsTarget) {\n    return initWatcher(check => {\n      const observer = new MutationObserver(check);\n      observer.observe(mutationsTarget, { subtree: true, childList: true });\n    });\n  }\n\n  function getMutationsTarget() {\n  // return document.querySelector('app-root + main');\n    return document.querySelector('body');\n  }\n\n  function getCheckinData(key) {\n    const STORAGE_PREFIX = 'ib-check-in-app';\n    const dataString = sessionStorage.getItem(`${STORAGE_PREFIX}.${key}`);\n    try { return JSON.parse(dataString); } catch (e) { return null; }\n  }\n\n  const STATE_ITEM = CAMPAIGN_PREFIX + '-seats-avail-state';\n\n  function getStoredState() {\n    return storage.getItem(STATE_ITEM);\n  }\n\n  function storeState(value) {\n    storage.setItem(STATE_ITEM, value);\n  }\n\n  function getSeatsAvailabilityState() {\n    return new Promise((resolve) => {\n      const checkinBookingInfo = getCheckinData('bookingInfo');\n      if (!checkinBookingInfo) throw Error('Booking info was not found');\n\n      const stateObj = {};\n      const allSegments = [\n        ...(checkinBookingInfo.outwardSegments || []),\n        ...(checkinBookingInfo.returnSegments || [])\n      ];\n\n      allSegments.forEach(dataObj => {\n        try {\n          dataObj.passengers.forEach((passengerData) => {\n            stateObj[dataObj.id + '-' + passengerData.id] = Boolean(passengerData.seat);\n          });\n        } catch (e) { /* silent */ }\n      });\n\n      resolve(stateObj);\n    });\n  }\n\n  function isCheckInSelectionPage() {\n    return location.hash.includes('ibcoac');\n  }\n\n  function isCheckInAncillariesPage() {\n    return location.hash.includes('ckianc');\n  }\n\n  logger.info('running');\n  init();\n\n  function init() {\n    processPassengersPage();\n    processAncillariesPage();\n  }\n\n  function processPassengersPage() {\n    onNodesAppear({\n      checkerFn: () => {\n        return (\n          getPassengersForm() &&\n        isCheckInSelectionPage()\n        );\n      },\n      onTrue: () => {\n        getSeatsAvailabilityState()\n          .then(stateObj => {\n            debugLogger.info('stateObj', stateObj);\n            storeState(stateObj);\n          })\n          .catch(error => {\n            debugLogger.error('Failed to get seats availability state:', error);\n            storeState({});\n          });\n      },\n      logger\n    });\n  }\n\n  function processAncillariesPage() {\n    onNodesAppear({\n      checkerFn: () => {\n        return (\n          getSeatsAllocationButton() &&\n        isCheckInAncillariesPage()\n        );\n      },\n      onTrue: () => {\n        getSeatsAvailabilityState()\n          .then(currentState => {\n            const storedState = getStoredState();\n\n            debugLogger('storedState', storedState);\n            debugLogger('currentState', currentState);\n\n            const wasSeatAssigned = Object.keys(storedState).some(id => {\n              const savedSeatStatus = storedState[id];\n              const currentSeatStatus = currentState[id];\n\n              return !savedSeatStatus && currentSeatStatus;\n            });\n\n            storeState(currentState);\n\n            if (wasSeatAssigned) {\n              registerAndExecute(applyVariant);\n            }\n          });\n      },\n      logger\n    });\n  }\n\n  function getSeatsAllocationButton() {\n    return document.querySelector('ib-seat-map-box .ib-box-card__button button');\n  }\n\n  function getPassengersForm() {\n    return document.querySelector('form[name=pasForm]');\n  }\n\n  function applyVariant() {\n    debugLogger('applyVariant');\n    getSeatsAllocationButton().click();\n  }\n})();\n//# sourceURL=url://LeanConvert/iberia271/variant-v1/js.js", "ref": "1123/5284895.js"});